--- shadow-4.0.3.orig/lib/prototypes.h
+++ shadow-4.0.3/lib/prototypes.h
@@ -37,6 +37,10 @@
 extern int isexpired(const struct passwd *);
 #endif
 
+#ifdef CONFIG_FLASK
+#include <linux/flask/flask_types.h>
+#endif
+
 /* basename() renamed to Basename() to avoid libc name space confusion */
 /* basename.c */
 extern char *Basename(char *str);
@@ -48,7 +52,11 @@
 extern int chown_tree(const char *, uid_t, uid_t, gid_t, gid_t);
 
 /* chowntty.c */
-extern void chown_tty(const char *, const struct passwd *);
+extern void chown_tty(const char *, const struct passwd *
+#ifdef CONFIG_FLASK
+, int FLASK_flag, security_id_t user_sid, security_id_t *ttyn_sid
+#endif
+);
 
 /* console.c */
 extern int console(const char *);
@@ -179,8 +187,16 @@
 /* setupenv.c */
 extern void setup_env(struct passwd *);
 
+#ifdef CONFIG_FLASK
+#include <linux/flask/flask_types.h>
+#endif
+
 /* shell.c */
-extern void shell(const char *, const char *);
+extern void shell(const char *, const char *
+#ifdef CONFIG_FLASK
+  , int FLASK_flag, security_id_t user_sid
+#endif
+ );
 
 #ifdef SHADOWPWD
 /* spdbm.c */
--- shadow-4.0.3.orig/src/su.c
+++ shadow-4.0.3/src/su.c
@@ -49,6 +49,7 @@
 #include <grp.h>
 #include <signal.h>
 #include <pwd.h>
+#include <getopt.h>
 #include "pwauth.h"
 #include "getdef.h"
 
@@ -79,6 +80,18 @@
 
 /* local function prototypes */
 
+/* If nonzero, change some environment vars to indicate the user su'd to.  */
+static int change_environment;
+
+static struct option const longopts[] =
+{
+  {"command", required_argument, 0, 'c'},
+  {"preserve-environment", no_argument, 0, 'p'},
+  {"shell", required_argument, 0, 's'},
+  {"help", no_argument, 0, 'h'},
+  {0, 0, 0, 0}
+};
+
 #ifndef USE_PAM
 
 static RETSIGTYPE die (int);
@@ -118,6 +131,96 @@
 }
 #endif				/* !USE_PAM */
 
+/* borrowed from GNU sh-utils' "su.c" */
+static int
+restricted_shell (const char *shell)
+{
+       char *line;
+
+       setusershell ();
+       while ((line = getusershell ()) != NULL) {
+               if (*line != '#' && strcmp (line, shell) == 0) {
+                       endusershell ();
+                       return 0;
+               }
+       }
+       endusershell ();
+       return 1;
+}
+
+/* borrowed from GNU sh-utils' "su.c" */
+static int
+elements (char **arr)
+{
+  int n = 0;
+
+  for (n = 0; *arr; ++arr)
+    ++n;
+  return n;
+}
+
+/* borrowed from GNU sh-utils' "su.c" */
+static void
+run_shell (char *shell, const char *command, char **additional_args, int login)
+{
+  const char **args;
+  int argno = 1;
+  char cmd[BUFSIZ];
+  int cmd_len_left = sizeof(cmd) - 1;
+
+  cmd[0] = '\0';
+
+  if (additional_args)
+    args = (const char **) xmalloc (sizeof (char *)
+                                    * (10 + elements (additional_args)));
+  else
+    args = (const char **) xmalloc (sizeof (char *) * 10);
+
+  if (login)
+    {
+      char *arg0;
+      char *shell_basename;
+
+      shell_basename = getdef_str("SU_NAME");
+      if (!shell_basename)
+       shell_basename = Basename(shell);
+
+      arg0 = xmalloc (strlen (shell_basename) + 2);
+      arg0[0] = '-';
+      strcpy (arg0 + 1, shell_basename);
+      args[0] = arg0;
+    }
+  else
+    args[0] = Basename(shell);
+  if (command || additional_args)
+    args[argno++] = "-c";
+  if (command) {
+    if (strlen(command) > cmd_len_left) {
+      fprintf(stderr, _("Command line args too long\n"));
+      exit(1);
+    }
+    strcat(cmd, command);
+    cmd_len_left -= strlen(command);
+  }
+  if (additional_args)
+    for (; *additional_args; ++additional_args) {
+      if ((strlen(*additional_args) + 1) > cmd_len_left) {
+	fprintf(stderr, _("Command line args too long\n"));
+	exit(1);
+      }
+      if (cmd[0]) {
+	strcat(cmd, " ");
+	cmd_len_left--;
+      }
+      strcat(cmd, *additional_args);
+      cmd_len_left -= strlen(*additional_args);
+    }
+  if (cmd[0]) args[argno++] = cmd;
+  args[argno] = NULL;
+  execv (shell, (char **) args);
+  fprintf (stderr, _("No shell\n"));
+  SYSLOG((LOG_WARN, "Cannot execute %s\n", shell));
+}
 
 static void su_failure (const char *tty)
 {
@@ -153,13 +256,14 @@
 {
 	char *cp;
 	const char *tty = 0;	/* Name of tty SU is run from        */
-	int doshell = 0;
 	int fakelogin = 0;
 	int amroot = 0;
 	uid_t my_uid;
 	struct passwd *pw = 0;
 	char **envp = environ;
-
+	char *command = 0, *shell = 0, **additional_args = 0;
+	int optc;
+	char *tmp_name;
 #ifdef USE_PAM
 	int ret;
 #else				/* !USE_PAM */
@@ -174,12 +278,14 @@
 #endif
 #endif				/* !USE_PAM */
 
-	sanitize_env ();
+	/* sanitize_env (); */
 
 	setlocale (LC_ALL, "");
 	bindtextdomain (PACKAGE, LOCALEDIR);
 	textdomain (PACKAGE);
 
+	change_environment = 1;
+
 	/*
 	 * Get the program name. The program name is used as a prefix to
 	 * most error messages.
@@ -224,14 +330,66 @@
 	 * Process the command line arguments. 
 	 */
 
-	argc--;
-	argv++;			/* shift out command name */
-
-	if (argc > 0 && strcmp (argv[0], "-") == 0) {
+	while ((optc = getopt_long (argc, argv, "c:mps:h", longopts, NULL)) != -1) {
+		switch (optc) {
+		    case 0:
+			break;
+		    case 'c':
+			command = optarg;
+			break;
+		    case 'm':
+		    case 'p':
+			change_environment = 0;
+			break;
+		    case 's':
+			shell = optarg;
+			break;
+		    default:
+			fprintf(stderr, _("\
+Usage: su [OPTS] [-] [username [ARGS]]\n\
+	-	make this a login shell\n\
+	-c, --command=<command>\n\
+		pass command to the invoked shell using its -c\n\
+		option\n\
+       -m, -p, --preserve-environment\n\
+		do not reset environment variables, and keep the\n\
+		same shell\n\
+       -s, --shell=<shell>\n\
+		use shell instead of the default in /etc/passwd\n"));
+			exit(1);
+		}
+	}
+	
+        if (optind < argc && !strcmp (argv[optind], "-")) {
 		fakelogin = 1;
-		argc--;
-		argv++;		/* shift ... */
+		++optind;
+	}
+
+	if (optind < argc)
+		strncpy(name, argv[optind++], sizeof(name) - 1);
+	else {
+	        struct passwd *root_pw = getpwuid(0);
+		if (root_pw == NULL) {
+		  SYSLOG((LOG_CRIT, "There is no UID 0 user."));
+		  su_failure(tty);
+		}
+                strcpy(name, root_pw->pw_name);
+	}
+
+	if (optind < argc)
+		additional_args = argv + optind;
+
+	/*
+	 * Get the user's real name.  The current UID is used to determine
+	 * who has executed su.  That user ID must exist.
+	 */
+
+	pw = get_my_pwent();
+	if (!pw) {
+		SYSLOG((LOG_CRIT, "Unknown UID: %d\n", (int) my_uid));
+		su_failure(tty);
 	}
+	STRFCPY(oldname, pw->pw_name);
 
 	/*
 	 * If a new login is being set up, the old environment will be
@@ -257,35 +415,6 @@
 			addenv (*envp++, NULL);
 	}
 
-	/*
-	 * The next argument must be either a user ID, or some flag to a
-	 * subshell. Pretty sticky since you can't have an argument which
-	 * doesn't start with a "-" unless you specify the new user name.
-	 * Any remaining arguments will be passed to the user's login shell.
-	 */
-
-	if (argc > 0 && argv[0][0] != '-') {
-		STRFCPY (name, argv[0]);	/* use this login id */
-		argc--;
-		argv++;		/* shift ... */
-	}
-	if (!name[0])		/* use default user ID */
-		(void) strcpy (name, "root");
-
-	doshell = argc == 0;	/* any arguments remaining? */
-
-	/*
-	 * Get the user's real name. The current UID is used to determine
-	 * who has executed su. That user ID must exist.
-	 */
-
-	pw = get_my_pwent ();
-	if (!pw) {
-		SYSLOG ((LOG_CRIT, "Unknown UID: %u", my_uid));
-		su_failure (tty);
-	}
-	STRFCPY (oldname, pw->pw_name);
-
 #ifndef USE_PAM
 #ifdef SU_ACCESS
 	/*
@@ -399,9 +528,17 @@
 	 * Set the default shell.
 	 */
 
-	if (pwent.pw_shell[0] == '\0')
-		pwent.pw_shell = "/bin/sh";	/* XXX warning: const */
+	if (pwent.pw_shell == NULL || pwent.pw_shell[0] == '\0')
+		pwent.pw_shell = (char *) "/bin/sh";
 
+	if (shell == 0 && change_environment == 0)
+		shell = getenv ("SHELL");
+	if (shell != 0 && getuid () && restricted_shell (pwent.pw_shell))
+		shell = 0;
+	if (shell == 0)
+	shell = (char *) strdup (pwent.pw_shell);
+
+	signal(SIGINT, SIG_IGN);
 #ifdef USE_PAM
 	ret = pam_authenticate (pamh, 0);
 	if (ret != PAM_SUCCESS) {
@@ -427,6 +564,14 @@
 			su_failure (tty);
 		}
 	}
+	ret = pam_get_item(pamh, PAM_USER, (const void **) &tmp_name);
+	if (ret != PAM_SUCCESS) {
+		SYSLOG((LOG_ERR, "pam_get_item: internal PAM error\n"));
+		fprintf(stderr, "%s: Internal PAM error retrieving username\n", Prog);
+		pam_end(pamh, ret);
+		su_failure(tty);
+	}
+	strncpy(name, tmp_name, sizeof(name) - 1);
 #else				/* !USE_PAM */
 	/*
 	 * Set up a signal handler in case the user types QUIT.
@@ -507,10 +652,14 @@
 	}
 #endif
 
-	environ = newenvp;	/* make new environment active */
-
-	if (getenv ("IFS"))	/* don't export user IFS ... */
-		addenv ("IFS= \t\n", NULL);	/* ... instead, set a safe IFS */
+	if (change_environment || restricted_shell(pwent.pw_shell)) {
+		environ = newenvp;			/* make new environment active */
+		if (getenv ("IFS"))			/* don't export user IFS ... */
+			addenv("IFS= \t\n", NULL);	/* ... instead, set a safe IFS */
+	} else {
+		if (getenv ("IFS"))
+			putenv("IFS= \t\n");
+	}
 
 	if (pwent.pw_shell[0] == '*') {	/* subsystem root required */
 		pwent.pw_shell++;	/* skip the '*' */
@@ -554,17 +703,56 @@
 		pam_end (pamh, ret);
 		exit (1);
 	}
+	ret = pam_open_session(pamh, 0);
+	if (ret != PAM_SUCCESS) {
+		SYSLOG((LOG_ERR, "pam_open_session: %s\n", pam_strerror(pamh, ret)));
+		fprintf(stderr, "%s: %s\n", Prog, pam_strerror(pamh, ret));
+		pam_setcred(pamh, PAM_DELETE_CRED);
+		pam_end(pamh, ret);
+		exit(1);
+	}
+	/* We must fork before setuid() because we need to call
+	 * pam_close_session() as root.
+	 */
+
+	/* We let the admin configure whether they need to keep login
+	   around to close sessions */
+	if (getdef_bool("CLOSE_SESSIONS")) {
+		pid_t pid;
+		int status;
+
+		signal(SIGINT, SIG_IGN);
+		pid = fork();
+
+		switch(pid) {
+		case -1:
+			SYSLOG((LOG_ERR, "su: fork failure: %m"));
+			perror("su: fork failure");
+			pam_setcred(pamh, PAM_DELETE_CRED);
+			pam_close_session(pamh, 0);
+			pam_end(pamh, PAM_ABORT);
+			exit(1);
+		case 0: /* child */
+			signal(SIGINT, SIG_DFL);
+			break;
+		default: /* parent */
+			waitpid(pid, &status, 0);
+			/* now we are done using PAM */
+			pam_setcred(pamh, PAM_DELETE_CRED);
+			ret = pam_close_session(pamh, 0);
+			pam_end(pamh, ret);
+			exit(WEXITSTATUS(status));
+		}
+	}
 
 	/* become the new user */
 	if (change_uid (&pwent)) {
+		pam_close_session(pamh, 0);
 		pam_setcred (pamh, PAM_DELETE_CRED);
 		pam_end (pamh, PAM_ABORT);
 		exit (1);
 	}
 
-	/* now we are done using PAM */
-	pam_end (pamh, PAM_SUCCESS);
-
 #else				/* !USE_PAM */
 	if (!amroot)		/* no limits if su from root */
 		setup_limits (&pwent);
@@ -573,11 +761,14 @@
 		exit (1);
 #endif				/* !USE_PAM */
 
-	if (fakelogin)
-		setup_env (&pwent);
+	if (fakelogin && (change_environment || restricted_shell(pwent.pw_shell)))
+		setup_env(&pwent);
 #if 1				/* Suggested by Joey Hess. XXX - is this right?  */
-	else
-		addenv ("HOME", pwent.pw_dir);
+	else if (change_environment || restricted_shell(pwent.pw_shell)) {
+		addenv("HOME", pwent.pw_dir);
+		addenv("USER", pwent.pw_name);
+		addenv("SHELL", shell);
+	}
 #endif
 
 	/*
@@ -589,46 +780,6 @@
 	 */
 	closelog ();
 
-	/*
-	 * See if the user has extra arguments on the command line. In that
-	 * case they will be provided to the new user's shell as arguments.
-	 */
-
-	if (fakelogin) {
-		char *arg0;
-
-#if 0				/* XXX - GNU su doesn't do this.  --marekm */
-		if (!hushed (&pwent)) {
-			motd ();
-			mailcheck ();
-		}
-#endif
-		cp = getdef_str ("SU_NAME");
-		if (!cp)
-			cp = Basename (pwent.pw_shell);
-
-		arg0 = xmalloc (strlen (cp) + 2);
-		arg0[0] = '-';
-		strcpy (arg0 + 1, cp);
-		cp = arg0;
-	} else
-		cp = Basename (pwent.pw_shell);
-
-	if (!doshell) {
-
-		/*
-		 * Use new user's shell from /etc/passwd and create an argv
-		 * with the rest of the command line included.
-		 */
-
-		argv[-1] = pwent.pw_shell;
-		(void) execv (pwent.pw_shell, &argv[-1]);
-		(void) fprintf (stderr, _("No shell\n"));
-		SYSLOG ((LOG_WARN, "Cannot execute %s", pwent.pw_shell));
-		closelog ();
-		exit (1);
-	}
-
-	shell (pwent.pw_shell, cp);
+	run_shell (shell, command, additional_args, fakelogin);
 	 /*NOTREACHED*/ exit (1);
 }
--- shadow-4.0.3.orig/src/groupadd.c
+++ shadow-4.0.3/src/groupadd.c
@@ -29,6 +29,8 @@
 
 #include <config.h>
 
+#undef USE_PAM
+
 #include "rcsid.h"
 RCSID (PKG_VER "$Id$")
 #include <sys/types.h>
--- shadow-4.0.3.orig/src/groupdel.c
+++ shadow-4.0.3/src/groupdel.c
@@ -29,6 +29,8 @@
 
 #include <config.h>
 
+#undef USE_PAM
+
 #include "rcsid.h"
 RCSID(PKG_VER "$Id$")
 
--- shadow-4.0.3.orig/src/groupmod.c
+++ shadow-4.0.3/src/groupmod.c
@@ -29,6 +29,8 @@
 
 #include <config.h>
 
+#undef USE_PAM
+
 #include "rcsid.h"
 RCSID (PKG_VER "$Id$")
 #include <sys/types.h>
--- shadow-4.0.3.orig/src/chpasswd.c
+++ shadow-4.0.3/src/chpasswd.c
@@ -29,6 +29,8 @@
 
 #include <config.h>
 
+#undef USE_PAM
+
 #include "rcsid.h"
 RCSID (PKG_VER "$Id$")
 #include <stdio.h>
--- shadow-4.0.3.orig/src/newusers.c
+++ shadow-4.0.3/src/newusers.c
@@ -35,6 +35,8 @@
 
 #include <config.h>
 
+#undef USE_PAM
+
 #include "rcsid.h"
 RCSID (PKG_VER "$Id$")
 #include <sys/types.h>
--- shadow-4.0.3.orig/src/login.c
+++ shadow-4.0.3/src/login.c
@@ -58,6 +58,11 @@
 #include <sys/proc.h>
 #include <sys/sysi86.h>
 #endif
+
+#ifndef MAXHOSTNAMELEN
+#define MAXHOSTNAMELEN 64
+#endif
+
 #ifdef RADIUS
 /*
  * Support for RADIUS authentication based on a hacked util-linux login
@@ -289,6 +294,8 @@
 	for (arg = 1; arg < argc; arg++) {
 		if (argv[arg][0] == '-' && strlen (argv[arg]) > 2)
 			usage ();
+		if (!strcmp(argv[arg], "--"))
+			break; /* stop checking on a "--" */
 	}
 }
 
@@ -424,11 +431,39 @@
 	static char temp_pw[2];
 	static char temp_shell[] = "/bin/sh";
 
+#ifdef CONFIG_FLASK
+#include <linux/flask/flask_types.h>
+#include <selinux/flask_util.h>
+#include <selinux/fs_secure.h>
+#include <selinux/ss.h>
+#include <selinux/get_user_sid.h>
+#endif
+
 #ifdef USE_PAM
 	int retcode;
 	pid_t child;
 	char *pam_user;
 #endif				/* USE_PAM */
+#ifdef CONFIG_FLASK
+#define CONTEXTLEN 255
+	security_context_t user_context;
+	int user_context_len = CONTEXTLEN;
+	security_id_t user_sid;
+	security_id_t* sidlist;
+#define SIDLISTLEN 10
+	int sidlistlen = SIDLISTLEN;
+	int num_sids = 0;
+	security_id_t ttyn_sid;  /* The current sid of ttyn device */
+	int FLASK_flag;
+#ifdef CHOWNCVS
+	security_id_t vcsn_sid;  /* The current sid of vcsn device */
+	security_id_t vcsan_sid;  /* The current sid of vcsan device */
+#endif
+	security_id_t newdev_sid;   /* The new sid of a device */
+	struct stat statbuf;
+	int flask_enabled;
+	int rc;
+#endif
 #if defined(SHADOWPWD) && !defined(USE_PAM)
 	struct spwd *spwd = NULL;
 #endif
@@ -466,7 +501,7 @@
 
 	check_flags (argc, argv);
 
-	while ((flag = getopt (argc, argv, "d:f:h:pr:")) != EOF) {
+	while ((flag = getopt (argc, argv, "d:f::h:pr:")) != EOF) {
 		switch (flag) {
 		case 'p':
 			pflg++;
@@ -475,11 +510,16 @@
 			/*
 			 * username must be a separate token
 			 * (-f root, *not* -froot).  --marekm
+ 			 *
+ 			 * if -f has an arg, use that, else use the
+ 			 * normal user name passed after all options
+ 			 * --benc
 			 */
-			if (optarg != argv[optind - 1])
+			if (optarg != NULL && optarg != argv[optind - 1])
 				usage ();
 			fflg++;
-			STRFCPY (username, optarg);
+			if (optarg)
+			  STRFCPY (username, optarg);
 			break;
 #ifdef	RLOGIN
 		case 'r':
@@ -633,7 +673,7 @@
 		init_env ();
 
 		if (optind < argc) {	/* get the user name */
-			if (rflg || fflg)
+			if (rflg || (fflg && username[0]))
 				usage ();
 
 #ifdef SVR4
@@ -763,49 +803,98 @@
 			 * MAX_LOGIN_TRIES?
 			 */
 
-			retcode = pam_authenticate (pamh, 0);
-			while ((failcount++ < retries) &&
-			       ((retcode == PAM_AUTH_ERR) ||
-				(retcode == PAM_USER_UNKNOWN) ||
-				(retcode == PAM_CRED_INSUFFICIENT) ||
-				(retcode == PAM_AUTHINFO_UNAVAIL))) {
-				pam_get_item (pamh, PAM_USER,
-					      (const void **) &pam_user);
-				syslog (LOG_NOTICE,
-					"FAILED LOGIN %d FROM %s FOR %s, %s",
-					failcount, hostname, pam_user,
-					pam_strerror (pamh, retcode));
-#ifdef HAVE_PAM_FAIL_DELAY
-				pam_fail_delay (pamh, 1000000 * delay);
+			failcount = 0;
+			while (1) {
+			  const char *failent_user;
+			  failed = 0;
+			  
+			  failcount++;
+			  if (delay > 0)
+			    retcode = pam_fail_delay(pamh, 1000000*delay);
+			  
+			  retcode = pam_authenticate (pamh, 0);
+			  
+			  pam_get_item (pamh, PAM_USER,
+					(const void **) &pam_user);
+			  
+			  if (pam_user && pam_user[0]) {
+			    pwd = getpwnam(pam_user);
+			    if (pwd) {
+			      pwent = *pwd;
+			      failent_user = pwent.pw_name;
+			    } else {
+			      if (getdef_bool("LOG_UNKFAIL_ENAB") && pam_user)
+				failent_user = pam_user;
+			      else
+				failent_user = "UNKNOWN";
+			    }
+			  } else {
+			    pwd = NULL;
+			    failent_user = "UNKNOWN";
+			  }
+			  
+			  if (retcode == PAM_MAXTRIES || failcount >= retries) {
+			    syslog (LOG_NOTICE,
+				    _("TOO MANY LOGIN TRIES (%d)%s FOR `%s'"),
+				    failcount, fromhost, failent_user);
+#ifndef USE_PAM
+			    if (pwd && getdef_bool("FAILLOG_ENAB"))
+			      failure (pwent.pw_uid, tty, &faillog);
+#endif
+			    fprintf(stderr,
+				    _("Maximum number of tries exceeded (%d)\n"),
+				    failcount);
+			    PAM_END;
+			    exit(0);
+			  } else if (retcode == PAM_ABORT) {
+			    /* Serious problems, quit now */
+			    fprintf(stderr,_("login: abort requested by PAM\n"));
+			    syslog(LOG_ERR,_("PAM_ABORT returned from pam_authenticate()"));
+			    PAM_END;
+			    exit(99);
+			  } else if (retcode != PAM_SUCCESS) {
+			    syslog(LOG_NOTICE,_("FAILED LOGIN (%d)%s FOR `%s', %s"),
+				   failcount, fromhost, failent_user,
+				   pam_strerror (pamh, retcode));
+			    failed = 1;
+			  }
+#ifndef USE_PAM
+			  if (pwd && getdef_bool("FAILLOG_ENAB") &&
+			      ! failcheck (pwent.pw_uid, &faillog, failed)) {
+			    SYSLOG((LOG_CRIT, FAILURE_CNT, failent_user, fromhost));
+			    failed = 1;
+			  }
 #endif
-				fprintf (stderr, "Login incorrect\n\n");
-				pam_set_item (pamh, PAM_USER, NULL);
-				retcode = pam_authenticate (pamh, 0);
-			}
 
-			if (retcode != PAM_SUCCESS) {
-				pam_get_item (pamh, PAM_USER,
-					      (const void **) &pam_user);
-
-				if (retcode == PAM_MAXTRIES)
-					syslog (LOG_NOTICE,
-						"TOO MANY LOGIN TRIES (%d) FROM %s FOR %s, %s",
-						failcount, hostname,
-						pam_user,
-						pam_strerror (pamh,
-							      retcode));
-				else
-					syslog (LOG_NOTICE,
-						"FAILED LOGIN SESSION FROM %s FOR %s, %s",
-						hostname, pam_user,
-						pam_strerror (pamh,
-							      retcode));
-
-				fprintf (stderr, "\nLogin incorrect\n");
-				pam_end (pamh, retcode);
-				exit (0);
+			  if (!failed)
+			    break;
+			  
+			  fprintf(stderr,"Login incorrect\n\n");
+#ifndef USE_PAM
+			  if (pwd && getdef_bool("FAILLOG_ENAB"))
+			    failure (pwent.pw_uid, tty, &faillog);
+#endif
+			  if (getdef_str("FTMP_FILE") != NULL) {
+#if HAVE_UTMPX_H
+			    failent = utxent;
+			    gettimeofday(&(failent.ut_tv), NULL);
+#else
+			    failent = utent;
+			    time(&failent.ut_time);
+#endif
+			    strncpy(failent.ut_user, failent_user, sizeof(failent.ut_user));
+#ifdef USER_PROCESS
+			    failent.ut_type = USER_PROCESS;
+#endif
+			    failtmp(&failent);
+			  }
+			  
+			  /* Let's give it another go around */
+			  pam_set_item(pamh,PAM_USER,NULL);
 			}
 
+			/* We don't get here unless they were authenticated above */
+			alarm(0);
 			retcode = pam_acct_mgmt (pamh, 0);
 
 			if (retcode == PAM_NEW_AUTHTOK_REQD) {
@@ -828,11 +917,14 @@
 
 		if (!pwd || setup_groups (pwd))
 			exit (1);
+		else
+		        pwent = *pwd;
 
 		retcode = pam_setcred (pamh, PAM_ESTABLISH_CRED);
 		PAM_FAIL_CHECK;
 
-		retcode = pam_open_session (pamh, 0);
+		retcode = pam_open_session (pamh,
+					    hushed(&pwent) ? PAM_SILENT : 0);
 		PAM_FAIL_CHECK;
 
 #else				/* ! USE_PAM */
@@ -1002,6 +1094,7 @@
 			failed = 1;
 		}
 #endif
+#ifndef USE_PAM
 		if (pwd && getdef_bool ("FAILLOG_ENAB") &&
 		    !failcheck (pwent.pw_uid, &faillog, failed)) {
 			SYSLOG ((LOG_CRIT, 
@@ -1009,12 +1102,15 @@
 				 username, fromhost));
 			failed = 1;
 		}
+#endif
 		if (!failed)
 			break;
 
+#ifndef USE_PAM
 		/* don't log non-existent users */
 		if (pwd && getdef_bool ("FAILLOG_ENAB"))
 			failure (pwent.pw_uid, tty, &faillog);
+#endif
 		if (getdef_str ("FTMP_FILE") != NULL) {
 			const char *failent_user;
 
@@ -1078,6 +1174,66 @@
 	}		/* while (1) */
 #endif				/* ! USE_PAM */
 	alarm (0);	/* turn off alarm clock */
+
+#ifdef CONFIG_FLASK
+	/* Make sure FLASK is really installed on this system */
+	if( (FLASK_flag = is_flask_enabled()) )
+	{
+		/* Get security context and SID for user */
+		sidlistlen = SIDLISTLEN;
+		sidlist = malloc (sidlistlen*sizeof(security_id_t));
+		if (sidlist == 0) {
+			fprintf(stderr, "login: no memory for SID list.\n");
+			exit (0);
+		}
+
+		num_sids = get_ordered_sid_list (pam_user, 0, sidlist, &sidlistlen);
+		if (num_sids <= 0 && sidlistlen > SIDLISTLEN) {
+			security_id_t *tmplist;
+			tmplist = realloc (sidlist, sidlistlen*sizeof(security_id_t));
+			if (tmplist) {
+				sidlist = tmplist;
+				num_sids = get_ordered_sid_list (pam_user, 0, sidlist, &sidlistlen);
+			}
+		}
+
+		if (num_sids <= 0)  {
+			fprintf(stderr, "login: unable to obtain SIDs for %s.\n", pam_user);
+			if (manual_user_enter_sid (pam_user, &user_sid))
+			{
+				syslog (LOG_ERR, "UNABLE TO GET VALID SID FOR %s", pam_user);
+				exit(0);
+			}
+		}
+		else
+		{
+			query_user_sid (sidlist, num_sids, &user_sid);
+		}
+		free (sidlist);
+		user_context_len = CONTEXTLEN;
+		user_context = malloc(user_context_len);
+		if (!user_context) {
+			fprintf(stderr, "login: no memory for security context.\n");
+			exit (0);
+		}
+		rc = security_sid_to_context(user_sid,user_context,&user_context_len);
+		if (rc < 0 && user_context_len > CONTEXTLEN)
+		{
+			security_context_t tmpcon;
+			tmpcon = realloc (user_context, user_context_len);
+			if (tmpcon) {
+				user_context = tmpcon;
+				rc = security_sid_to_context (user_sid, user_context, &user_context_len);
+			}
+		}
+		if (rc < 0) {
+			free (user_context);
+			syslog (LOG_ERR, "PROBLEM OBTAINING CONTEXT FOR %s", pam_user);
+			exit (0);
+		}
+	}
+#endif
+
 #ifndef USE_PAM			/* PAM does this */
 	/*
 	 * porttime checks moved here, after the user has been
@@ -1172,7 +1328,11 @@
 #endif
 	setup_limits (&pwent);	/* nice, ulimit etc. */
 #endif				/* ! USE_PAM */
-	chown_tty (tty, &pwent);
+	chown_tty(tty, &pwent
+#ifdef CONFIG_FLASK
+	, FLASK_flag, user_sid, &ttyn_sid
+#endif
+	);
 
 #ifdef LOGIN_FBTAB
 	/*
@@ -1338,6 +1498,16 @@
 			 * session
 			 */
 			wait (NULL);
+#ifdef CONFIG_FLASK
+			if (FLASK_flag)
+			{
+				/* We need to change the contexts of the
+				 * terminal devices back to the system when
+				 * the user's session ends.  */
+				if(chsid(tty, ttyn_sid) != 0)
+					perror("chsid");
+			}
+#endif
 			PAM_END;
 			exit (0);
 		}
@@ -1354,10 +1524,33 @@
 #ifdef	SHADOWGRP
 	endsgent ();	/* stop access to shadow group file */
 #endif
+#ifdef CONFIG_FLASK
+	if(FLASK_flag)
+	{
+		if(pwent.pw_uid == 0)
+			SYSLOG((LOG_NOTICE, "ROOT LOGIN %s", fromhost));
+		else if(getdef_bool("LOG_OK_LOGINS"))
+#ifdef USE_PAM
+			SYSLOG((LOG_INFO, "`%s' logged in %s", pam_user, fromhost, user_context));
+#else
+			SYSLOG((LOG_INFO, "`%s' logged in %s", username, fromhost, user_context));
+#endif
+		free(user_context);
+	}
+	else
+	{
+#endif
 	if (pwent.pw_uid == 0)
 		SYSLOG ((LOG_NOTICE, "ROOT LOGIN %s", fromhost));
 	else if (getdef_bool ("LOG_OK_LOGINS"))
+#ifdef USE_PAM
+		SYSLOG ((LOG_INFO, "`%s' logged in %s", pam_user, fromhost));
+#else
 		SYSLOG ((LOG_INFO, "`%s' logged in %s", username, fromhost));
+#endif
+#ifdef CONFIG_FLASK
+	}
+#endif
 	closelog ();
 #ifdef RADIUS
 	if (is_rad_login) {
@@ -1367,8 +1560,16 @@
 	}
 #endif
 	if ((tmp = getdef_str ("FAKE_SHELL")) != NULL) {
-		shell (tmp, pwent.pw_shell);	/* fake shell */
+		shell (tmp, pwent.pw_shell
+#ifdef CONFIG_FLASK
+		, FLASK_flag, user_sid
+#endif
+	);	/* fake shell */
 	}
-	shell (pwent.pw_shell, (char *) 0);	/* exec the shell finally. */
+	shell(pwent.pw_shell, (char *) 0
+#ifdef CONFIG_FLASK
+		, FLASK_flag, user_sid
+#endif
+	);	/* exec the shell finally. */
 	 /*NOTREACHED*/ return 0;
 }
--- shadow-4.0.3.orig/src/passwd.c
+++ shadow-4.0.3/src/passwd.c
@@ -1173,8 +1173,8 @@
 
 	if (!amroot && pw->pw_uid != getuid ()) {
 		fprintf (stderr,
-			 _("You may not change the password for %s.\n"),
-			 name);
+			 _("%s: You may not view or modify password information for %s.\n"),
+			 Prog, name);
 		SYSLOG ((LOG_WARN, "can't change pwd for `%s'", name));
 		closelog ();
 		exit (E_NOPERM);
--- shadow-4.0.3.orig/src/cppw.c
+++ shadow-4.0.3/src/cppw.c
@@ -0,0 +1,200 @@
+/*
+  cppw, cpgr  copy with locking given file over the password or group file
+  with -s will copy with locking given file over shadow or gshadow file
+ 
+  Copyright (C) 1999 Stephen Frost <sfrost@snowman.net>
+
+  Based on vipw, vigr by:
+  Copyright (C) 1997 Guy Maor <maor@ece.utexas.edu>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+  */
+
+#include <config.h>
+#include "defines.h"
+
+#include <errno.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <signal.h>
+#include <utime.h>
+#include "prototypes.h"
+#include "pwio.h"
+#include "shadowio.h"
+#include "groupio.h"
+#include "sgroupio.h"
+
+
+static const char *progname, *filename, *filenewname;
+static int filelocked = 0;
+static int (*unlock)();
+
+/* local function prototypes */
+static int create_backup_file (FILE *, const char *, struct stat *);
+static void cppwexit (const char *, int, int);
+static void cppwcopy (const char *, const char *, int (*) (void), int (*) (void));
+int main (int, char **);
+
+static int
+create_backup_file(FILE *fp, const char *backup, struct stat *sb)
+{
+  struct utimbuf ub;
+  FILE *bkfp;
+  int c;
+  mode_t mask;
+
+  mask = umask(077);
+  bkfp = fopen(backup, "w");
+  umask(mask);
+  if (!bkfp) return -1;
+
+  rewind(fp);
+  while ((c = getc(fp)) != EOF) {
+    if (putc(c, bkfp) == EOF) break;
+  }
+
+  if (c != EOF || fflush(bkfp)) {
+    fclose(bkfp);
+    unlink(backup);
+    return -1;
+  }
+  if (fclose(bkfp)) {
+    unlink(backup);
+    return -1;
+  }
+
+  ub.actime = sb->st_atime;
+  ub.modtime = sb->st_mtime;
+  if (utime(backup, &ub) ||
+      chmod(backup, sb->st_mode) ||
+      chown(backup, sb->st_uid, sb->st_gid)) {
+    unlink(backup);
+    return -1;
+  }
+  return 0;
+}
+
+static void
+cppwexit(const char *msg, int syserr, int ret)
+{
+  int err = errno;
+  if (filelocked) (*unlock)();
+  if (msg) fprintf(stderr, "%s: %s", progname, msg);
+  if (syserr) fprintf(stderr, ": %s", strerror(err));
+  fprintf(stderr, "\n%s: %s is unchanged\n", progname, filename);
+  exit(ret);
+}
+
+static void
+cppwcopy(const char *file, const char *in_file, int (*file_lock) (void), int (*file_unlock) (void))
+{
+  struct stat st1;
+  FILE *f;
+  char filenew[1024];
+
+  snprintf(filenew, sizeof filenew, "%s.new", file);
+  unlock = file_unlock;
+  filename = file;
+  filenewname = filenew;
+  
+  if (access(file, F_OK)) cppwexit(file, 1, 1);
+  if (!file_lock()) cppwexit("Couldn't lock file", errno, 5);
+  filelocked = 1;
+
+  /* file to copy has same owners, perm */
+  if (stat(file, &st1)) cppwexit(file, 1, 1);
+  if (!(f = fopen(in_file, "r"))) cppwexit(file, 1, 1);
+  if (create_backup_file(f, filenew, &st1))
+    cppwexit("Couldn't make backup", errno, 1);
+  
+  /* XXX - here we should check filenew for errors; if there are any,
+     fail w/ an appropriate error code and let the user manually fix
+     it. Use pwck or grpck to do the check.  - Stephen (Shamelessly
+     stolen from '--marekm's comment) */
+
+  if (rename(filenew, file) == -1) {
+    fprintf(stderr, "%s: can't copy %s: %s)\n",
+	    progname, filenew, strerror(errno));
+    cppwexit(0,0,1);
+  }
+
+  (*file_unlock)();
+}
+
+
+int
+main(int argc, char **argv)
+{
+  int flag;
+  int cpshadow = 0;
+  char *in_file;
+  char *c;
+  int e = 1;
+  int do_cppw;
+
+  progname = ((c = strrchr(*argv, '/')) ? c+1 : *argv);
+  do_cppw = (strcmp(progname, "cpgr") != 0);
+
+  while ((flag = getopt(argc, argv, "ghps")) != EOF) {
+    switch (flag) {
+    case 'p':
+      do_cppw = 1;
+      break;
+    case 'g':
+      do_cppw = 0;
+      break;
+    case 's':
+      cpshadow = 1;
+      break;
+    case 'h':
+      e = 0;
+    default:
+      printf("Usage:\n\
+`cppw <file>' copys over /etc/passwd   `cppw -s <file>' copys over /etc/shadow\n\
+`cpgr <file>' copys over /etc/group    `cpgr -s <file>' copys over /etc/gshadow\n\
+");
+      exit(e);
+    }
+  }
+
+  if (optind >= argc) {
+    cppwexit ("missing file argument, -h for usage",0,1);
+  }
+
+  in_file = argv[argc - 1];
+
+  if (do_cppw) {
+#ifdef SHADOWPWD
+    if (cpshadow)
+      cppwcopy(SHADOW_FILE, in_file, spw_lock, spw_unlock);
+    else
+#endif
+      cppwcopy(PASSWD_FILE, in_file, pw_lock, pw_unlock);
+  }
+  else {
+#ifdef SHADOWGRP
+    if (cpshadow)
+      cppwcopy(SGROUP_FILE, in_file, sgr_lock, sgr_unlock);
+    else
+#endif
+      cppwcopy(GROUP_FILE, in_file, gr_lock, gr_unlock);
+  }
+
+  return 0;
+}
--- shadow-4.0.3.orig/src/Makefile.am
+++ shadow-4.0.3/src/Makefile.am
@@ -25,7 +25,7 @@
 ubin_PROGRAMS = faillog lastlog chage chfn chsh expiry gpasswd newgrp passwd
 usbin_PROGRAMS = chpasswd dpasswd groupadd groupdel groupmod \
 	logoutd mkpasswd newusers useradd userdel usermod grpck \
-	pwck vipw grpconv grpunconv pwconv pwunconv
+	pwck vipw grpconv grpunconv pwconv pwunconv cppw
 
 noinst_PROGRAMS = id sulogin
 
@@ -34,7 +34,9 @@
 suidbins = su
 suidubins = chage chfn chsh expiry gpasswd newgrp passwd
 
-LDADD = $(top_builddir)/libmisc/libmisc.la \
+LDADD =
+
+LDADD += $(top_builddir)/libmisc/libmisc.la \
 	$(top_builddir)/lib/libshadow.la
 
 chpasswd_LDADD = $(LDADD) $(LIBPAM)
@@ -44,17 +46,18 @@
 groupadd_LDADD = $(LDADD) $(LIBPAM)
 groupdel_LDADD = $(LDADD) $(LIBPAM)
 groupmod_LDADD = $(LDADD) $(LIBPAM)
-login_LDADD    = $(LDADD) $(LIBPAM)
+login_LDADD    = $(LDADD) $(LIBPAM) $(SEC_LDADD)
 newusers_LDADD = $(LDADD) $(LIBPAM)
 passwd_LDADD   = $(LDADD) $(LIBPAM) $(LIBCRACK)
 su_SOURCES     = su.c suauth.c
-su_LDADD       = $(LDADD) $(LIBPAM)
+su_LDADD       = $(LDADD) $(LIBPAM) $(SEC_LDADD)
 useradd_LDADD  = $(LDADD) $(LIBPAM)
 userdel_LDADD  = $(LDADD) $(LIBPAM)
 usermod_LDADD  = $(LDADD) $(LIBPAM)
+newgrp_LDADD   = $(LDADD) $(LIBPAM) $(SEC_LDADD)
+sulogin_LDADD  = $(LDADD) $(LIBPAM) $(SEC_LDADD)
 
 install-exec-hook:
-	ln -sf newgrp	$(DESTDIR)$(bindir)/sg
 	ln -sf vigr	$(DESTDIR)$(bindir)/vipw
 	for i in $(suidbins); do \
 		chmod 4755 $(DESTDIR)$(bindir)/$$i; \
--- shadow-4.0.3.orig/src/grpck.c
+++ shadow-4.0.3/src/grpck.c
@@ -146,6 +146,7 @@
 	int errors = 0;
 	int deleted = 0;
 	int i;
+	int prune = 0;
 	struct commonio_entry *gre, *tgre;
 	struct group *grp;
 	int sort_mode = 0;
@@ -172,7 +173,7 @@
 	 * Parse the command line arguments
 	 */
 
-	while ((arg = getopt (argc, argv, "qrs")) != EOF) {
+	while ((arg = getopt (argc, argv, "qprs")) != EOF) {
 		switch (arg) {
 		case 'q':
 			/* quiet - ignored for now */
@@ -183,6 +184,9 @@
 		case 's':
 			sort_mode = 1;
 			break;
+		case 'p':
+			prune = 1;
+			break;
 		default:
 			usage ();
 		}
@@ -315,9 +319,13 @@
 			/*
 			 * prompt the user to delete the entry or not
 			 */
-
-			if (!yes_or_no ())
+			if (!prune) {
+			        if (!yes_or_no ())
+				        continue;
+			} else {
+			        puts("Yes");
 				continue;
+			}
 
 			/*
 			 * All group file deletions wind up here. This code
--- shadow-4.0.3.orig/src/newgrp.c
+++ shadow-4.0.3/src/newgrp.c
@@ -91,7 +91,7 @@
 
 #if ENABLE_NLS
 	/* XXX - remove when gettext is safe to use in setuid programs */
-	sanitize_env ();
+	/* sanitize_env ();*/
 #endif
 
 	setlocale (LC_ALL, "");
@@ -386,8 +386,13 @@
 		SYSLOG ((LOG_INFO, "user `%s' switched to group `%s'",
 			 name, group));
 	if (getdef_bool ("SYSLOG_SG_ENAB")) {
-		char *loginname = xstrdup (getlogin ());
-		char *tty = xstrdup (ttyname (0));
+		char *loginname = getlogin ();
+		char *tty = ttyname (0);
+
+		if (loginname != NULL)
+		  loginname = xstrdup (loginname);
+		if (tty != NULL)
+		  tty = xstrdup (tty);
 
 		if (loginname == NULL)
 			loginname = "???";
@@ -586,7 +591,11 @@
 	 * the previous environment which should be the user's login shell.
 	 */
 
-	shell (prog, initflag ? (char *) 0 : cp);
+	shell(prog, initflag ? (char *) 0 : cp
+#ifdef CONFIG_FLASK
+		, 0, 0
+#endif
+	);
        /*NOTREACHED*/ failure:
 
 	/*
--- shadow-4.0.3.orig/src/useradd.c
+++ shadow-4.0.3/src/useradd.c
@@ -29,6 +29,8 @@
 
 #include <config.h>
 
+#undef USE_PAM
+
 #include "rcsid.h"
 RCSID (PKG_VER "$Id$")
 #include "prototypes.h"
--- shadow-4.0.3.orig/src/userdel.c
+++ shadow-4.0.3/src/userdel.c
@@ -29,6 +29,8 @@
 
 #include <config.h>
 
+#undef USE_PAM
+
 #include "rcsid.h"
 RCSID (PKG_VER "$Id$")
 #include <sys/stat.h>
@@ -147,6 +149,7 @@
 	struct group *ngrp;
 
 #ifdef	SHADOWGRP
+	int deleted_user_group = 0;
 	const struct sgrp *sgrp;
 	struct sgrp *nsgrp;
 #endif				/* SHADOWGRP */
@@ -209,6 +212,10 @@
 
 		gr_remove (grp->gr_name);
 
+#ifdef SHADOWGRP
+		deleted_user_group = 1;
+#endif
+
 		/*
 		 * Update the DBM group file with the new entry as well.
 		 */
@@ -279,6 +286,10 @@
 		SYSLOG ((LOG_INFO, "delete `%s' from shadow group `%s'\n",
 			 user_name, nsgrp->sg_name));
 	}
+
+	if (deleted_user_group)
+		sgr_remove(user_name);
+
 #ifdef	NDBM
 	endsgent ();
 #endif				/* NDBM */
--- shadow-4.0.3.orig/src/usermod.c
+++ shadow-4.0.3/src/usermod.c
@@ -29,6 +29,8 @@
 
 #include <config.h>
 
+#undef USE_PAM
+
 #include "rcsid.h"
 RCSID (PKG_VER "$Id$")
 #include <sys/types.h>
@@ -1544,9 +1546,14 @@
 				if (copy_tree (user_home, user_newhome,
 					       uflg ? user_newid : -1,
 					       gflg ? user_newgid : -1) ==
-				    0 && remove_tree (user_home) == 0
-				    && rmdir (user_home) == 0)
-					return;
+				    0) {
+				  if (remove_tree (user_home) != 0 ||
+				    rmdir (user_home) != 0)
+				    fprintf (stderr,
+					     _("%s: warning: failed to completely remove old home directory %s"),
+					     Prog, user_home);
+				  return;
+				}
 
 				(void) remove_tree (user_newhome);
 				(void) rmdir (user_newhome);
--- shadow-4.0.3.orig/src/sulogin.c
+++ shadow-4.0.3/src/sulogin.c
@@ -268,6 +268,10 @@
 #ifdef	USE_SYSLOG
 	closelog ();
 #endif
-	shell (pwent.pw_shell, (char *) 0);	/* exec the shell finally. */
+	shell(pwent.pw_shell, (char *) 0
+#ifdef CONFIG_FLASK
+		, 0, 0
+#endif
+	);	/* exec the shell finally. */
 	 /*NOTREACHED*/ return (0);
 }
--- shadow-4.0.3.orig/src/chage.c
+++ shadow-4.0.3/src/chage.c
@@ -29,6 +29,8 @@
 
 #include <config.h>
 
+#undef USE_PAM
+
 #include "rcsid.h"
 RCSID (PKG_VER "$Id$")
 #include <sys/types.h>
--- shadow-4.0.3.orig/libmisc/sub.c
+++ shadow-4.0.3/libmisc/sub.c
@@ -75,4 +75,8 @@
 		closelog();
 		exit (1);
 	}
+
+	/* Now fixup the shell to get rid of that '*' */
+	if (*pw->pw_shell == '*')
+		pw->pw_shell++;
 }
--- shadow-4.0.3.orig/libmisc/pam_pass.c
+++ shadow-4.0.3/libmisc/pam_pass.c
@@ -51,6 +51,7 @@
 		exit(10);  /* XXX */
 	}
 
+	fputs("passwd: password updated successfully\n", stderr);
 	pam_end(pamh, PAM_SUCCESS);
 }
 #else /* !USE_PAM */
--- shadow-4.0.3.orig/libmisc/shell.c
+++ shadow-4.0.3/libmisc/shell.c
@@ -55,7 +55,11 @@
  */
 
 void
-shell(const char *file, const char *arg)
+shell(const char *file, const char *arg
+#ifdef CONFIG_FLASK
+  , int FLASK_flag, security_id_t user_sid
+#endif
+ )
 {
 	char arg0[1024];
 	int err;
@@ -84,6 +88,11 @@
 	 * grief.
 	 */
 
+#ifdef CONFIG_FLASK
+	if(FLASK_flag)
+		execle_secure(file, user_sid, arg, (char *) 0, newenvp);
+	else
+#endif
 	execle (file, arg, (char *) 0, newenvp);
 	err = errno;
 
@@ -103,6 +112,11 @@
 		if ((fp = fopen (file, "r"))) {
 			if (getc (fp) == '#' && getc (fp) == '!') {
 				fclose (fp);
+#ifdef CONFIG_FLASK
+				if(FLASK_flag)
+					execle ("/bin/sh", user_sid, "sh", file, (char *) 0, newenvp);
+				else
+#endif
 				execle ("/bin/sh", "sh",
 					file, (char *) 0, newenvp);
 				err = errno;
--- shadow-4.0.3.orig/libmisc/getdate.c
+++ shadow-4.0.3/libmisc/getdate.c
@@ -1,26 +1,24 @@
-
-/*  A Bison parser, made from getdate.y
- by  GNU Bison version 1.25
-  */
+/* A Bison parser, made from getdate.y
+   by GNU bison 1.33.  */
 
 #define YYBISON 1  /* Identify Bison output.  */
 
-#define	tAGO	258
-#define	tDAY	259
-#define	tDAY_UNIT	260
-#define	tDAYZONE	261
-#define	tDST	262
-#define	tHOUR_UNIT	263
-#define	tID	264
-#define	tMERIDIAN	265
-#define	tMINUTE_UNIT	266
-#define	tMONTH	267
-#define	tMONTH_UNIT	268
-#define	tSEC_UNIT	269
-#define	tSNUMBER	270
-#define	tUNUMBER	271
-#define	tYEAR_UNIT	272
-#define	tZONE	273
+# define	tAGO	257
+# define	tDAY	258
+# define	tDAY_UNIT	259
+# define	tDAYZONE	260
+# define	tDST	261
+# define	tHOUR_UNIT	262
+# define	tID	263
+# define	tMERIDIAN	264
+# define	tMINUTE_UNIT	265
+# define	tMONTH	266
+# define	tMONTH_UNIT	267
+# define	tSEC_UNIT	268
+# define	tSNUMBER	269
+# define	tUNUMBER	270
+# define	tYEAR_UNIT	271
+# define	tZONE	272
 
 #line 1 "getdate.y"
 
@@ -197,16 +195,15 @@
 
 
 #line 175 "getdate.y"
+#ifndef YYSTYPE
 typedef union {
     int			Number;
     enum _MERIDIAN	Meridian;
-} YYSTYPE;
-#include <stdio.h>
-
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
+} yystype;
+# define YYSTYPE yystype
 #endif
+#ifndef YYDEBUG
+# define YYDEBUG 0
 #endif
 
 
@@ -215,159 +212,187 @@
 #define	YYFLAG		-32768
 #define	YYNTBASE	22
 
-#define YYTRANSLATE(x) ((unsigned)(x) <= 273 ? yytranslate[x] : 32)
+/* YYTRANSLATE(YYLEX) -- Bison token number corresponding to YYLEX. */
+#define YYTRANSLATE(x) ((unsigned)(x) <= 272 ? yytranslate[x] : 32)
 
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,    20,     2,     2,    21,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,    19,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
-     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
-    16,    17,    18
+/* YYTRANSLATE[YYLEX] -- Bison token number corresponding to YYLEX. */
+static const char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,    20,     2,     2,    21,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    19,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     3,     4,     5,
+       6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18
 };
 
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     1,     4,     6,     8,    10,    12,    14,    16,    19,
-    24,    29,    36,    43,    45,    47,    50,    52,    55,    58,
-    62,    68,    72,    76,    79,    84,    87,    91,    94,    96,
-    99,   102,   104,   107,   110,   112,   115,   118,   120,   123,
-   126,   128,   131,   134,   136,   139,   142,   144,   146,   147
+#if YYDEBUG
+static const short yyprhs[] =
+{
+       0,     0,     1,     4,     6,     8,    10,    12,    14,    16,
+      19,    24,    29,    36,    43,    45,    47,    50,    52,    55,
+      58,    62,    68,    72,    76,    79,    84,    87,    91,    94,
+      96,    99,   102,   104,   107,   110,   112,   115,   118,   120,
+     123,   126,   128,   131,   134,   136,   139,   142,   144,   146,
+     147
 };
-
-static const short yyrhs[] = {    -1,
-    22,    23,     0,    24,     0,    25,     0,    27,     0,    26,
-     0,    28,     0,    30,     0,    16,    10,     0,    16,    19,
-    16,    31,     0,    16,    19,    16,    15,     0,    16,    19,
-    16,    19,    16,    31,     0,    16,    19,    16,    19,    16,
-    15,     0,    18,     0,     6,     0,    18,     7,     0,     4,
-     0,     4,    20,     0,    16,     4,     0,    16,    21,    16,
-     0,    16,    21,    16,    21,    16,     0,    16,    15,    15,
-     0,    16,    12,    15,     0,    12,    16,     0,    12,    16,
-    20,    16,     0,    16,    12,     0,    16,    12,    16,     0,
-    29,     3,     0,    29,     0,    16,    17,     0,    15,    17,
-     0,    17,     0,    16,    13,     0,    15,    13,     0,    13,
-     0,    16,     5,     0,    15,     5,     0,     5,     0,    16,
-     8,     0,    15,     8,     0,     8,     0,    16,    11,     0,
-    15,    11,     0,    11,     0,    16,    14,     0,    15,    14,
-     0,    14,     0,    16,     0,     0,    10,     0
+static const short yyrhs[] =
+{
+      -1,    22,    23,     0,    24,     0,    25,     0,    27,     0,
+      26,     0,    28,     0,    30,     0,    16,    10,     0,    16,
+      19,    16,    31,     0,    16,    19,    16,    15,     0,    16,
+      19,    16,    19,    16,    31,     0,    16,    19,    16,    19,
+      16,    15,     0,    18,     0,     6,     0,    18,     7,     0,
+       4,     0,     4,    20,     0,    16,     4,     0,    16,    21,
+      16,     0,    16,    21,    16,    21,    16,     0,    16,    15,
+      15,     0,    16,    12,    15,     0,    12,    16,     0,    12,
+      16,    20,    16,     0,    16,    12,     0,    16,    12,    16,
+       0,    29,     3,     0,    29,     0,    16,    17,     0,    15,
+      17,     0,    17,     0,    16,    13,     0,    15,    13,     0,
+      13,     0,    16,     5,     0,    15,     5,     0,     5,     0,
+      16,     8,     0,    15,     8,     0,     8,     0,    16,    11,
+       0,    15,    11,     0,    11,     0,    16,    14,     0,    15,
+      14,     0,    14,     0,    16,     0,     0,    10,     0
 };
 
 #endif
 
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-   191,   192,   195,   198,   201,   204,   207,   210,   213,   219,
-   225,   234,   240,   252,   255,   258,   264,   268,   272,   278,
-   282,   300,   306,   312,   316,   321,   325,   332,   340,   343,
-   346,   349,   352,   355,   358,   361,   364,   367,   370,   373,
-   376,   379,   382,   385,   388,   391,   394,   399,   432,   436
+#if YYDEBUG
+/* YYRLINE[YYN] -- source line where rule number YYN was defined. */
+static const short yyrline[] =
+{
+       0,   191,   192,   195,   198,   201,   204,   207,   210,   213,
+     219,   225,   234,   240,   252,   255,   258,   264,   268,   272,
+     278,   282,   300,   306,   312,   316,   321,   325,   332,   340,
+     343,   346,   349,   352,   355,   358,   361,   364,   367,   370,
+     373,   376,   379,   382,   385,   388,   391,   394,   399,   432,
+     436
 };
 #endif
 
 
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+#if (YYDEBUG) || defined YYERROR_VERBOSE
 
-static const char * const yytname[] = {   "$","error","$undefined.","tAGO","tDAY",
-"tDAY_UNIT","tDAYZONE","tDST","tHOUR_UNIT","tID","tMERIDIAN","tMINUTE_UNIT",
-"tMONTH","tMONTH_UNIT","tSEC_UNIT","tSNUMBER","tUNUMBER","tYEAR_UNIT","tZONE",
-"':'","','","'/'","spec","item","time","zone","day","date","rel","relunit","number",
-"o_merid", NULL
+/* YYTNAME[TOKEN_NUM] -- String name of the token TOKEN_NUM. */
+static const char *const yytname[] =
+{
+  "$", "error", "$undefined.", "tAGO", "tDAY", "tDAY_UNIT", "tDAYZONE", 
+  "tDST", "tHOUR_UNIT", "tID", "tMERIDIAN", "tMINUTE_UNIT", "tMONTH", 
+  "tMONTH_UNIT", "tSEC_UNIT", "tSNUMBER", "tUNUMBER", "tYEAR_UNIT", 
+  "tZONE", "':'", "','", "'/'", "spec", "item", "time", "zone", "day", 
+  "date", "rel", "relunit", "number", "o_merid", NULL
 };
 #endif
 
-static const short yyr1[] = {     0,
-    22,    22,    23,    23,    23,    23,    23,    23,    24,    24,
-    24,    24,    24,    25,    25,    25,    26,    26,    26,    27,
-    27,    27,    27,    27,    27,    27,    27,    28,    28,    29,
-    29,    29,    29,    29,    29,    29,    29,    29,    29,    29,
-    29,    29,    29,    29,    29,    29,    29,    30,    31,    31
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives. */
+static const short yyr1[] =
+{
+       0,    22,    22,    23,    23,    23,    23,    23,    23,    24,
+      24,    24,    24,    24,    25,    25,    25,    26,    26,    26,
+      27,    27,    27,    27,    27,    27,    27,    27,    28,    28,
+      29,    29,    29,    29,    29,    29,    29,    29,    29,    29,
+      29,    29,    29,    29,    29,    29,    29,    29,    30,    31,
+      31
 };
 
-static const short yyr2[] = {     0,
-     0,     2,     1,     1,     1,     1,     1,     1,     2,     4,
-     4,     6,     6,     1,     1,     2,     1,     2,     2,     3,
-     5,     3,     3,     2,     4,     2,     3,     2,     1,     2,
-     2,     1,     2,     2,     1,     2,     2,     1,     2,     2,
-     1,     2,     2,     1,     2,     2,     1,     1,     0,     1
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN. */
+static const short yyr2[] =
+{
+       0,     0,     2,     1,     1,     1,     1,     1,     1,     2,
+       4,     4,     6,     6,     1,     1,     2,     1,     2,     2,
+       3,     5,     3,     3,     2,     4,     2,     3,     2,     1,
+       2,     2,     1,     2,     2,     1,     2,     2,     1,     2,
+       2,     1,     2,     2,     1,     2,     2,     1,     1,     0,
+       1
 };
 
-static const short yydefact[] = {     1,
-     0,    17,    38,    15,    41,    44,     0,    35,    47,     0,
-    48,    32,    14,     2,     3,     4,     6,     5,     7,    29,
-     8,    18,    24,    37,    40,    43,    34,    46,    31,    19,
-    36,    39,     9,    42,    26,    33,    45,     0,    30,     0,
-     0,    16,    28,     0,    23,    27,    22,    49,    20,    25,
-    50,    11,     0,    10,     0,    49,    21,    13,    12,     0,
-     0
+/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
+   doesn't specify something else to do.  Zero means the default is an
+   error. */
+static const short yydefact[] =
+{
+       1,     0,    17,    38,    15,    41,    44,     0,    35,    47,
+       0,    48,    32,    14,     2,     3,     4,     6,     5,     7,
+      29,     8,    18,    24,    37,    40,    43,    34,    46,    31,
+      19,    36,    39,     9,    42,    26,    33,    45,     0,    30,
+       0,     0,    16,    28,     0,    23,    27,    22,    49,    20,
+      25,    50,    11,     0,    10,     0,    49,    21,    13,    12,
+       0,     0
 };
 
-static const short yydefgoto[] = {     1,
-    14,    15,    16,    17,    18,    19,    20,    21,    54
+static const short yydefgoto[] =
+{
+       1,    14,    15,    16,    17,    18,    19,    20,    21,    54
 };
 
-static const short yypact[] = {-32768,
-     0,   -19,-32768,-32768,-32768,-32768,   -13,-32768,-32768,    30,
-    15,-32768,    14,-32768,-32768,-32768,-32768,-32768,-32768,    19,
--32768,-32768,     4,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
--32768,-32768,-32768,-32768,    -6,-32768,-32768,    16,-32768,    17,
-    23,-32768,-32768,    24,-32768,-32768,-32768,    27,    28,-32768,
--32768,-32768,    29,-32768,    32,    -8,-32768,-32768,-32768,    50,
--32768
+static const short yypact[] =
+{
+  -32768,     0,   -19,-32768,-32768,-32768,-32768,   -13,-32768,-32768,
+      30,    15,-32768,    14,-32768,-32768,-32768,-32768,-32768,-32768,
+      19,-32768,-32768,     4,-32768,-32768,-32768,-32768,-32768,-32768,
+  -32768,-32768,-32768,-32768,-32768,    -6,-32768,-32768,    16,-32768,
+      17,    23,-32768,-32768,    24,-32768,-32768,-32768,    27,    28,
+  -32768,-32768,-32768,    29,-32768,    32,    -8,-32768,-32768,-32768,
+      50,-32768
 };
 
-static const short yypgoto[] = {-32768,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    -5
+static const short yypgoto[] =
+{
+  -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    -5
 };
 
 
 #define	YYLAST		51
 
 
-static const short yytable[] = {    60,
-    22,    51,    23,     2,     3,     4,    58,     5,    45,    46,
-     6,     7,     8,     9,    10,    11,    12,    13,    30,    31,
-    42,    43,    32,    44,    33,    34,    35,    36,    37,    38,
-    47,    39,    48,    40,    24,    41,    51,    25,    49,    50,
-    26,    52,    27,    28,    56,    53,    29,    57,    55,    61,
-    59
+static const short yytable[] =
+{
+      60,    22,    51,    23,     2,     3,     4,    58,     5,    45,
+      46,     6,     7,     8,     9,    10,    11,    12,    13,    30,
+      31,    42,    43,    32,    44,    33,    34,    35,    36,    37,
+      38,    47,    39,    48,    40,    24,    41,    51,    25,    49,
+      50,    26,    52,    27,    28,    56,    53,    29,    57,    55,
+      61,    59
 };
 
-static const short yycheck[] = {     0,
-    20,    10,    16,     4,     5,     6,    15,     8,    15,    16,
-    11,    12,    13,    14,    15,    16,    17,    18,     4,     5,
-     7,     3,     8,    20,    10,    11,    12,    13,    14,    15,
-    15,    17,    16,    19,     5,    21,    10,     8,    16,    16,
-    11,    15,    13,    14,    16,    19,    17,    16,    21,     0,
-    56
+static const short yycheck[] =
+{
+       0,    20,    10,    16,     4,     5,     6,    15,     8,    15,
+      16,    11,    12,    13,    14,    15,    16,    17,    18,     4,
+       5,     7,     3,     8,    20,    10,    11,    12,    13,    14,
+      15,    15,    17,    16,    19,     5,    21,    10,     8,    16,
+      16,    11,    15,    13,    14,    16,    19,    17,    16,    21,
+       0,    56
 };
 /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/share/bison.simple"
+#line 3 "/usr/share/bison/bison.simple"
 
 /* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software
+   Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -381,183 +406,328 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
 
 /* As a special exception, when this file is copied by Bison into a
    Bison output file, you may use that output file without restriction.
    This special exception was added by the Free Software Foundation
    in version 1.24 of Bison.  */
 
-#ifndef alloca
-#ifdef __GNUC__
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
-#include <alloca.h>
-#else /* not sparc */
-#if defined (MSDOS) && !defined (__TURBOC__)
-#include <malloc.h>
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-#include <malloc.h>
- #pragma alloca
-#else /* not MSDOS, __TURBOC__, or _AIX */
-#ifdef __hpux
+/* This is the parser code that is written into each bison parser when
+   the %semantic_parser declaration is not specified in the grammar.
+   It was written by Richard Stallman by simplifying the hairy parser
+   used when %semantic_parser is specified.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
 #ifdef __cplusplus
-extern "C" {
-void *alloca (unsigned int);
+# define YYSTD(x) std::x
+#else
+# define YYSTD(x) x
+#endif
+
+#if ! defined (yyoverflow) || defined (YYERROR_VERBOSE)
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# if YYSTACK_USE_ALLOCA
+#  define YYSTACK_ALLOC alloca
+# else
+#  ifndef YYSTACK_USE_ALLOCA
+#   if defined (alloca) || defined (_ALLOCA_H)
+#    define YYSTACK_ALLOC alloca
+#   else
+#    ifdef __GNUC__
+#     define YYSTACK_ALLOC __builtin_alloca
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+# else
+#  ifdef __cplusplus
+#   include <cstdlib> /* INFRINGES ON USER NAME SPACE */
+#   define YYSIZE_T std::size_t
+#  else
+#   ifdef __STDC__
+#    include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#    define YYSIZE_T size_t
+#   endif
+#  endif
+#  define YYSTACK_ALLOC YYSTD (malloc)
+#  define YYSTACK_FREE YYSTD (free)
+# endif
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short yyss;
+  YYSTYPE yyvs;
+# if YYLSP_NEEDED
+  YYLTYPE yyls;
+# endif
 };
-#else /* not __cplusplus */
-void *alloca ();
-#endif /* not __cplusplus */
-#endif /* __hpux */
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc.  */
-#endif /* not GNU C.  */
-#endif /* alloca not defined.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# if YYLSP_NEEDED
+#  define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\
+      + 2 * YYSTACK_GAP_MAX)
+# else
+#  define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+      + YYSTACK_GAP_MAX)
+# endif
+
+/* Relocate the TYPE STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Type, Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	yymemcpy ((char *) yyptr, (char *) (Stack),			\
+		  yysize * (YYSIZE_T) sizeof (Type));			\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (Type) + YYSTACK_GAP_MAX;	\
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
+
+#endif /* ! defined (yyoverflow) || defined (YYERROR_VERBOSE) */
+
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# ifdef __cplusplus
+#  include <cstddef> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T std::size_t
+# else
+#  ifdef __STDC__
+#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#   define YYSIZE_T size_t
+#  endif
+# endif
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
 
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		-2
 #define YYEOF		0
-#define YYACCEPT	return(0)
-#define YYABORT 	return(1)
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT 	goto yyabortlab
 #define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
    Once GCC version 2 has supplanted version 1, this can go.  */
 #define YYFAIL		goto yyerrlab
 #define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
+#define YYBACKUP(Token, Value)					\
 do								\
   if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
       yychar1 = YYTRANSLATE (yychar);				\
       YYPOPSTACK;						\
       goto yybackup;						\
     }								\
   else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+    { 								\
+      yyerror ("syntax error: cannot back up");			\
+      YYERROR;							\
+    }								\
 while (0)
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
 
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
-
-/* If nonreentrant, generate the variables here */
+/* YYLLOC_DEFAULT -- Compute the default location (before the actions
+   are run).
 
-#ifndef YYPURE
-
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
-
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
+   When YYLLOC_DEFAULT is run, CURRENT is set the location of the
+   first token.  By default, to implement support for ranges, extend
+   its range to the last symbol.  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)       	\
+   Current.last_line   = Rhs[N].last_line;	\
+   Current.last_column = Rhs[N].last_column;
 #endif
 
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
 
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
-#endif
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#if YYPURE
+# if YYLSP_NEEDED
+#  ifdef YYLEX_PARAM
+#   define YYLEX		yylex (&yylval, &yylloc, YYLEX_PARAM)
+#  else
+#   define YYLEX		yylex (&yylval, &yylloc)
+#  endif
+# else /* !YYLSP_NEEDED */
+#  ifdef YYLEX_PARAM
+#   define YYLEX		yylex (&yylval, YYLEX_PARAM)
+#  else
+#   define YYLEX		yylex (&yylval)
+#  endif
+# endif /* !YYLSP_NEEDED */
+#else /* !YYPURE */
+# define YYLEX			yylex ()
+#endif /* !YYPURE */
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  ifdef __cplusplus
+#   include <cstdio>  /* INFRINGES ON USER NAME SPACE */
+#  else
+#   include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  endif
+#  define YYFPRINTF YYSTD (fprintf)
+# endif
 
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+/* Nonzero means print parse trace. [The following comment makes no
+   sense to me.  Could someone clarify it?  --akim] Since this is
+   uninitialized, it does not stop multiple parsers from coexisting.
+   */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+#endif /* !YYDEBUG */
 
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
 #ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
+# define YYINITDEPTH 200
 #endif
 
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
 
 #if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
+# undef YYMAXDEPTH
 #endif
 
 #ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
-#endif
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-int yyparse (void);
+# define YYMAXDEPTH 10000
 #endif
 
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
+#if ! defined (yyoverflow) && ! defined (yymemcpy)
+# if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
+#  define yymemcpy __builtin_memcpy
+# else				/* not GNU C or C++ */
 
 /* This is the most reliable way to avoid incompatibilities
    in available built-in functions on various systems.  */
 static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
+#  if defined (__STDC__) || defined (__cplusplus)
+yymemcpy (char *yyto, const char *yyfrom, YYSIZE_T yycount)
+#  else
+yymemcpy (yyto, yyfrom, yycount)
+     char *yyto;
+     const char *yyfrom;
+     YYSIZE_T yycount;
+#  endif
+{
+  register const char *yyf = yyfrom;
+  register char *yyt = yyto;
+  register YYSIZE_T yyi = yycount;
 
-  while (i-- > 0)
-    *t++ = *f++;
+  while (yyi-- != 0)
+    *yyt++ = *yyf++;
 }
+# endif
+#endif
 
-#else /* __cplusplus */
+#ifdef YYERROR_VERBOSE
 
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, int count)
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
 {
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
+  register const char *yys = yystr;
 
-  while (i-- > 0)
-    *t++ = *f++;
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
 }
+#  endif
+# endif
 
-#endif
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  register char *yyd = yydest;
+  register const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
 #endif
 
-#line 196 "/usr/share/bison.simple"
+#line 341 "/usr/share/bison/bison.simple"
+
 
 /* The user can define YYPARSE_PARAM as the name of an argument to be passed
    into yyparse.  The argument should have type void *.
@@ -566,66 +736,121 @@
    to the proper pointer type.  */
 
 #ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
+# ifdef __cplusplus
+#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL
+# else /* !__cplusplus */
+#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+# endif /* !__cplusplus */
+#else /* !YYPARSE_PARAM */
+# define YYPARSE_PARAM_ARG
+# define YYPARSE_PARAM_DECL
+#endif /* !YYPARSE_PARAM */
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+# ifdef YYPARSE_PARAM
+int yyparse (void *);
+# else
+int yyparse (void);
+# endif
+#endif
+
+/* YY_DECL_VARIABLES -- depending whether we use a pure parser,
+   variables are global, or local to YYPARSE.  */
+
+#define YY_DECL_NON_LSP_VARIABLES			\
+/* The lookahead symbol.  */				\
+int yychar;						\
+							\
+/* The semantic value of the lookahead symbol. */	\
+YYSTYPE yylval;						\
+							\
+/* Number of parse errors so far.  */			\
+int yynerrs;
+
+#if YYLSP_NEEDED
+# define YY_DECL_VARIABLES			\
+YY_DECL_NON_LSP_VARIABLES			\
+						\
+/* Location data for the lookahead symbol.  */	\
+YYLTYPE yylloc;
+#else
+# define YY_DECL_VARIABLES			\
+YY_DECL_NON_LSP_VARIABLES
+#endif
+
+
+/* If nonreentrant, generate the variables here. */
+
+#if !YYPURE
+YY_DECL_VARIABLES
+#endif  /* !YYPURE */
 
 int
-yyparse(YYPARSE_PARAM_ARG)
+yyparse (YYPARSE_PARAM_ARG)
      YYPARSE_PARAM_DECL
 {
+  /* If reentrant, generate the variables here. */
+#if YYPURE
+  YY_DECL_VARIABLES
+#endif  /* !YYPURE */
+
   register int yystate;
   register int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yychar1 = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack. */
+  short	yyssa[YYINITDEPTH];
+  short *yyss = yyssa;
   register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
-
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
 
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  register YYSTYPE *yyvsp;
 
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
+#if YYLSP_NEEDED
+  /* The location stack.  */
+  YYLTYPE yylsa[YYINITDEPTH];
   YYLTYPE *yyls = yylsa;
   YYLTYPE *yylsp;
+#endif
 
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#if YYLSP_NEEDED
+# define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
 #else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
+# define YYPOPSTACK   (yyvsp--, yyssp--)
 #endif
 
-  int yystacksize = YYINITDEPTH;
+  YYSIZE_T yystacksize = YYINITDEPTH;
 
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
 
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+#if YYLSP_NEEDED
+  YYLTYPE yyloc;
+#endif
 
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule. */
   int yylen;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
+  YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
@@ -637,96 +862,106 @@
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
 
-  yyssp = yyss - 1;
+  yyssp = yyss;
   yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   yylsp = yyls;
 #endif
+  goto yysetstate;
 
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
 
-  *++yyssp = yystate;
+ yysetstate:
+  *yyssp = yystate;
 
   if (yyssp >= yyss + yystacksize - 1)
     {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
       /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
+      YYSIZE_T yysize = yyssp - yyss + 1;
 
 #ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  */
+# if YYLSP_NEEDED
+	YYLTYPE *yyls1 = yyls;
+	/* This used to be a conditional around just the two extra args,
+	   but that might be undefined if yyoverflow is a macro.  */
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yyls1, yysize * sizeof (*yylsp),
+		    &yystacksize);
+	yyls = yyls1;
+# else
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+# endif
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
 #else /* no yyoverflow */
       /* Extend the stack our own way.  */
       if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  return 2;
-	}
+	goto yyoverflowlab;
       yystacksize *= 2;
       if (yystacksize > YYMAXDEPTH)
 	yystacksize = YYMAXDEPTH;
-      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
-      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
-#endif
+
+      {
+	short *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyoverflowlab;
+	YYSTACK_RELOCATE (short, yyss);
+	YYSTACK_RELOCATE (YYSTYPE, yyvs);
+# if YYLSP_NEEDED
+	YYSTACK_RELOCATE (YYLTYPE, yyls);
+# endif
+# undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
 #endif /* no yyoverflow */
 
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+#if YYLSP_NEEDED
+      yylsp = yyls + yysize - 1;
 #endif
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
 
       if (yyssp >= yyss + yystacksize - 1)
 	YYABORT;
     }
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
   goto yybackup;
- yybackup:
+
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
 
 /* Do appropriate processing given the current state.  */
 /* Read a lookahead token if we need one and don't already have one.  */
@@ -745,10 +980,7 @@
 
   if (yychar == YYEMPTY)
     {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
+      YYDPRINTF ((stderr, "Reading a token: "));
       yychar = YYLEX;
     }
 
@@ -759,25 +991,25 @@
       yychar1 = 0;
       yychar = YYEOF;		/* Don't call YYLEX any more */
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
   else
     {
-      yychar1 = YYTRANSLATE(yychar);
+      yychar1 = YYTRANSLATE (yychar);
 
-#if YYDEBUG != 0
+#if YYDEBUG
+     /* We have to keep this `#if YYDEBUG', since we use variables
+	which are defined only if `YYDEBUG' is set.  */
       if (yydebug)
 	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
+	  YYFPRINTF (stderr, "Next token is %d (%s",
+		     yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise
+	     meaning of a token, for further debugging info.  */
+# ifdef YYPRINT
 	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
+# endif
+	  YYFPRINTF (stderr, ")\n");
 	}
 #endif
     }
@@ -809,88 +1041,110 @@
     YYACCEPT;
 
   /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
+  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
+	      yychar, yytname[yychar1]));
 
   /* Discard the token being shifted unless it is eof.  */
   if (yychar != YYEOF)
     yychar = YYEMPTY;
 
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   *++yylsp = yylloc;
 #endif
 
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
 
   yystate = yyn;
   goto yynewstate;
 
-/* Do the default action for the current state.  */
-yydefault:
 
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
+  goto yyreduce;
+
 
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
 yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
   yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
 
-#if YYDEBUG != 0
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to the semantic value of
+     the lookahead token.  This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+#if YYLSP_NEEDED
+  /* Similarly for the default location.  Let the user run additional
+     commands if for instance locations are ranges.  */
+  yyloc = yylsp[1-yylen];
+  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
+#endif
+
+#if YYDEBUG
+  /* We have to keep this `#if YYDEBUG', since we use variables which
+     are defined only if `YYDEBUG' is set.  */
   if (yydebug)
     {
-      int i;
+      int yyi;
 
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
+      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
+		 yyn, yyrline[yyn]);
 
       /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+      for (yyi = yyprhs[yyn]; yyrhs[yyi] > 0; yyi++)
+	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
+      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
     }
 #endif
 
-
   switch (yyn) {
 
 case 3:
 #line 195 "getdate.y"
 {
 	    yyHaveTime++;
-	;
-    break;}
+	}
+    break;
 case 4:
 #line 198 "getdate.y"
 {
 	    yyHaveZone++;
-	;
-    break;}
+	}
+    break;
 case 5:
 #line 201 "getdate.y"
 {
 	    yyHaveDate++;
-	;
-    break;}
+	}
+    break;
 case 6:
 #line 204 "getdate.y"
 {
 	    yyHaveDay++;
-	;
-    break;}
+	}
+    break;
 case 7:
 #line 207 "getdate.y"
 {
 	    yyHaveRel++;
-	;
-    break;}
+	}
+    break;
 case 9:
 #line 213 "getdate.y"
 {
@@ -898,8 +1152,8 @@
 	    yyMinutes = 0;
 	    yySeconds = 0;
 	    yyMeridian = yyvsp[0].Meridian;
-	;
-    break;}
+	}
+    break;
 case 10:
 #line 219 "getdate.y"
 {
@@ -907,8 +1161,8 @@
 	    yyMinutes = yyvsp[-1].Number;
 	    yySeconds = 0;
 	    yyMeridian = yyvsp[0].Meridian;
-	;
-    break;}
+	}
+    break;
 case 11:
 #line 225 "getdate.y"
 {
@@ -919,8 +1173,8 @@
 	    yyTimezone = (yyvsp[0].Number < 0
 			  ? -yyvsp[0].Number % 100 + (-yyvsp[0].Number / 100) * 60
 			  : - (yyvsp[0].Number % 100 + (yyvsp[0].Number / 100) * 60));
-	;
-    break;}
+	}
+    break;
 case 12:
 #line 234 "getdate.y"
 {
@@ -928,8 +1182,8 @@
 	    yyMinutes = yyvsp[-3].Number;
 	    yySeconds = yyvsp[-1].Number;
 	    yyMeridian = yyvsp[0].Meridian;
-	;
-    break;}
+	}
+    break;
 case 13:
 #line 240 "getdate.y"
 {
@@ -941,54 +1195,54 @@
 	    yyTimezone = (yyvsp[0].Number < 0
 			  ? -yyvsp[0].Number % 100 + (-yyvsp[0].Number / 100) * 60
 			  : - (yyvsp[0].Number % 100 + (yyvsp[0].Number / 100) * 60));
-	;
-    break;}
+	}
+    break;
 case 14:
 #line 252 "getdate.y"
 {
 	    yyTimezone = yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 15:
 #line 255 "getdate.y"
 {
 	    yyTimezone = yyvsp[0].Number - 60;
-	;
-    break;}
+	}
+    break;
 case 16:
 #line 259 "getdate.y"
 {
 	    yyTimezone = yyvsp[-1].Number - 60;
-	;
-    break;}
+	}
+    break;
 case 17:
 #line 264 "getdate.y"
 {
 	    yyDayOrdinal = 1;
 	    yyDayNumber = yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 18:
 #line 268 "getdate.y"
 {
 	    yyDayOrdinal = 1;
 	    yyDayNumber = yyvsp[-1].Number;
-	;
-    break;}
+	}
+    break;
 case 19:
 #line 272 "getdate.y"
 {
 	    yyDayOrdinal = yyvsp[-1].Number;
 	    yyDayNumber = yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 20:
 #line 278 "getdate.y"
 {
 	    yyMonth = yyvsp[-2].Number;
 	    yyDay = yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 21:
 #line 282 "getdate.y"
 {
@@ -1008,8 +1262,8 @@
 	      yyDay = yyvsp[-2].Number;
 	      yyYear = yyvsp[0].Number;
 	    }
-	;
-    break;}
+	}
+    break;
 case 22:
 #line 300 "getdate.y"
 {
@@ -1017,8 +1271,8 @@
 	    yyYear = yyvsp[-2].Number;
 	    yyMonth = -yyvsp[-1].Number;
 	    yyDay = -yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 23:
 #line 306 "getdate.y"
 {
@@ -1026,38 +1280,38 @@
 	    yyDay = yyvsp[-2].Number;
 	    yyMonth = yyvsp[-1].Number;
 	    yyYear = -yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 24:
 #line 312 "getdate.y"
 {
 	    yyMonth = yyvsp[-1].Number;
 	    yyDay = yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 25:
 #line 316 "getdate.y"
 {
 	    yyMonth = yyvsp[-3].Number;
 	    yyDay = yyvsp[-2].Number;
 	    yyYear = yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 26:
 #line 321 "getdate.y"
 {
 	    yyMonth = yyvsp[0].Number;
 	    yyDay = yyvsp[-1].Number;
-	;
-    break;}
+	}
+    break;
 case 27:
 #line 325 "getdate.y"
 {
 	    yyMonth = yyvsp[-1].Number;
 	    yyDay = yyvsp[-2].Number;
 	    yyYear = yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 28:
 #line 332 "getdate.y"
 {
@@ -1067,116 +1321,116 @@
 	    yyRelDay = -yyRelDay;
 	    yyRelMonth = -yyRelMonth;
 	    yyRelYear = -yyRelYear;
-	;
-    break;}
+	}
+    break;
 case 30:
 #line 343 "getdate.y"
 {
 	    yyRelYear += yyvsp[-1].Number * yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 31:
 #line 346 "getdate.y"
 {
 	    yyRelYear += yyvsp[-1].Number * yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 32:
 #line 349 "getdate.y"
 {
 	    yyRelYear++;
-	;
-    break;}
+	}
+    break;
 case 33:
 #line 352 "getdate.y"
 {
 	    yyRelMonth += yyvsp[-1].Number * yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 34:
 #line 355 "getdate.y"
 {
 	    yyRelMonth += yyvsp[-1].Number * yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 35:
 #line 358 "getdate.y"
 {
 	    yyRelMonth++;
-	;
-    break;}
+	}
+    break;
 case 36:
 #line 361 "getdate.y"
 {
 	    yyRelDay += yyvsp[-1].Number * yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 37:
 #line 364 "getdate.y"
 {
 	    yyRelDay += yyvsp[-1].Number * yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 38:
 #line 367 "getdate.y"
 {
 	    yyRelDay++;
-	;
-    break;}
+	}
+    break;
 case 39:
 #line 370 "getdate.y"
 {
 	    yyRelHour += yyvsp[-1].Number * yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 40:
 #line 373 "getdate.y"
 {
 	    yyRelHour += yyvsp[-1].Number * yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 41:
 #line 376 "getdate.y"
 {
 	    yyRelHour++;
-	;
-    break;}
+	}
+    break;
 case 42:
 #line 379 "getdate.y"
 {
 	    yyRelMinutes += yyvsp[-1].Number * yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 43:
 #line 382 "getdate.y"
 {
 	    yyRelMinutes += yyvsp[-1].Number * yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 44:
 #line 385 "getdate.y"
 {
 	    yyRelMinutes++;
-	;
-    break;}
+	}
+    break;
 case 45:
 #line 388 "getdate.y"
 {
 	    yyRelSeconds += yyvsp[-1].Number * yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 46:
 #line 391 "getdate.y"
 {
 	    yyRelSeconds += yyvsp[-1].Number * yyvsp[0].Number;
-	;
-    break;}
+	}
+    break;
 case 47:
 #line 394 "getdate.y"
 {
 	    yyRelSeconds++;
-	;
-    break;}
+	}
+    break;
 case 48:
 #line 400 "getdate.y"
 {
@@ -1208,64 +1462,50 @@
 		    yyMeridian = MER24;
 		  }
 	      }
-	  ;
-    break;}
+	  }
+    break;
 case 49:
 #line 433 "getdate.y"
 {
 	    yyval.Meridian = MER24;
-	  ;
-    break;}
+	  }
+    break;
 case 50:
 #line 437 "getdate.y"
 {
 	    yyval.Meridian = yyvsp[0].Meridian;
-	  ;
-    break;}
+	  }
+    break;
 }
-   /* the action file gets copied in in place of this dollarsign */
-#line 498 "/usr/share/bison.simple"
+
+#line 727 "/usr/share/bison/bison.simple"
+
 
   yyvsp -= yylen;
   yyssp -= yylen;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   yylsp -= yylen;
 #endif
 
-#if YYDEBUG != 0
+#if YYDEBUG
   if (yydebug)
     {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
+      short *yyssp1 = yyss - 1;
+      YYFPRINTF (stderr, "state stack now");
+      while (yyssp1 != yyssp)
+	YYFPRINTF (stderr, " %d", *++yyssp1);
+      YYFPRINTF (stderr, "\n");
     }
 #endif
 
   *++yyvsp = yyval;
-
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
+#if YYLSP_NEEDED
+  *++yylsp = yyloc;
 #endif
 
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
 
   yyn = yyr1[yyn];
 
@@ -1277,10 +1517,13 @@
 
   goto yynewstate;
 
-yyerrlab:   /* here on detecting error */
 
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
     {
       ++yynerrs;
 
@@ -1289,102 +1532,121 @@
 
       if (yyn > YYFLAG && yyn < YYLAST)
 	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
+	  YYSIZE_T yysize = 0;
+	  char *yymsg;
+	  int yyx, yycount;
+
+	  yycount = 0;
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  for (yyx = yyn < 0 ? -yyn : 0;
+	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
+	    if (yycheck[yyx + yyn] == yyx)
+	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
+	  yysize += yystrlen ("parse error, unexpected ") + 1;
+	  yysize += yystrlen (yytname[YYTRANSLATE (yychar)]);
+	  yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg != 0)
 	    {
-	      strcpy(msg, "parse error");
+	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
+	      yyp = yystpcpy (yyp, yytname[YYTRANSLATE (yychar)]);
 
-	      if (count < 5)
+	      if (yycount < 5)
 		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
+		  yycount = 0;
+		  for (yyx = yyn < 0 ? -yyn : 0;
+		       yyx < (int) (sizeof (yytname) / sizeof (char *));
+		       yyx++)
+		    if (yycheck[yyx + yyn] == yyx)
 		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
+			const char *yyq = ! yycount ? ", expecting " : " or ";
+			yyp = yystpcpy (yyp, yyq);
+			yyp = yystpcpy (yyp, yytname[yyx]);
+			yycount++;
 		      }
 		}
-	      yyerror(msg);
-	      free(msg);
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
 	    }
 	  else
-	    yyerror ("parse error; also virtual memory exceeded");
+	    yyerror ("parse error; also virtual memory exhausted");
 	}
       else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
+#endif /* defined (YYERROR_VERBOSE) */
+	yyerror ("parse error");
     }
-
   goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
 
+
+/*--------------------------------------------------.
+| yyerrlab1 -- error raised explicitly by an action |
+`--------------------------------------------------*/
+yyerrlab1:
   if (yyerrstatus == 3)
     {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
 
       /* return failure if at end of input */
       if (yychar == YYEOF)
 	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
-
+      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
+		  yychar, yytname[yychar1]));
       yychar = YYEMPTY;
     }
 
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
 
   yyerrstatus = 3;		/* Each real token shifted decrements this */
 
   goto yyerrhandle;
 
-yyerrdefault:  /* current state does not do anything special for the error token. */
 
+/*-------------------------------------------------------------------.
+| yyerrdefault -- current state does not do anything special for the |
+| error token.                                                       |
+`-------------------------------------------------------------------*/
+yyerrdefault:
 #if 0
   /* This is wrong; only states that explicitly want error tokens
      should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
+
+  /* If its default is to accept any token, ok.  Otherwise pop it.  */
+  yyn = yydefact[yystate];
+  if (yyn)
+    goto yydefault;
 #endif
 
-yyerrpop:   /* pop the current state because it cannot handle the error token */
 
-  if (yyssp == yyss) YYABORT;
+/*---------------------------------------------------------------.
+| yyerrpop -- pop the current state because it cannot handle the |
+| error token                                                    |
+`---------------------------------------------------------------*/
+yyerrpop:
+  if (yyssp == yyss)
+    YYABORT;
   yyvsp--;
   yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   yylsp--;
 #endif
 
-#if YYDEBUG != 0
+#if YYDEBUG
   if (yydebug)
     {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
+      short *yyssp1 = yyss - 1;
+      YYFPRINTF (stderr, "Error: state stack now");
+      while (yyssp1 != yyssp)
+	YYFPRINTF (stderr, " %d", *++yyssp1);
+      YYFPRINTF (stderr, "\n");
     }
 #endif
 
+/*--------------.
+| yyerrhandle.  |
+`--------------*/
 yyerrhandle:
-
   yyn = yypact[yystate];
   if (yyn == YYFLAG)
     goto yyerrdefault;
@@ -1407,18 +1669,45 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
+  YYDPRINTF ((stderr, "Shifting error token, "));
 
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   *++yylsp = yylloc;
 #endif
 
   yystate = yyn;
   goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+/*---------------------------------------------.
+| yyoverflowab -- parser overflow comes here.  |
+`---------------------------------------------*/
+yyoverflowlab:
+  yyerror ("parser stack overflow");
+  yyresult = 2;
+  /* Fall through.  */
+
+yyreturn:
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  return yyresult;
 }
 #line 442 "getdate.y"
 
--- shadow-4.0.3.orig/libmisc/chowntty.c
+++ shadow-4.0.3/libmisc/chowntty.c
@@ -44,6 +44,11 @@
 #include <pwd.h>
 #include "getdef.h"
 
+#ifdef CONFIG_FLASK
+#include <selinux/ss.h>
+#include <selinux/fs_secure.h>
+#endif
+
 /*
  * is_my_tty -- determine if "tty" is the same as TTY stdin is using
  */
@@ -68,12 +73,20 @@
  */
 
 void
-chown_tty(const char *tty, const struct passwd *info)
+chown_tty(const char *tty, const struct passwd *info
+#ifdef CONFIG_FLASK
+, int FLASK_flag, security_id_t user_sid, security_id_t *ttyn_sid
+#endif
+)
 {
 	char buf[200], full_tty[200];
 	char	*group;		/* TTY group name or number */
 	struct	group	*grent;
 	gid_t gid;
+#ifdef CONFIG_FLASK
+	security_id_t newdev_sid;   /* The new sid of a device */
+	struct stat statbuf;
+#endif
 
 	/*
 	 * See if login.defs has some value configured for the port group
@@ -116,9 +129,29 @@
 			tty, info->pw_name));
 		closelog();
 
-		if (!(err == EROFS && info->pw_uid == 0))
+		if (err != EROFS)
 			exit(1);
 	}
+#ifdef CONFIG_FLASK
+	if(FLASK_flag)
+	{
+		if(stat_secure(tty, &statbuf, ttyn_sid) != 0)
+		{
+			perror("stat_secure");
+			exit (0);
+		}
+		if(security_change_sid (user_sid, *ttyn_sid, SECCLASS_CHR_FILE, &newdev_sid) != 0)
+		{
+			perror("security_change_sid");
+			exit (0);
+		}
+		if(chsid(tty, newdev_sid) != 0)
+		{
+			perror("chsid");
+			exit(0);
+		}
+	}
+#endif
 
 #ifdef __linux__
 	/*
--- shadow-4.0.3.orig/libmisc/failure.c
+++ shadow-4.0.3/libmisc/failure.c
@@ -39,7 +39,11 @@
 #include "getdef.h"
 #include "failure.h"
 
+#ifdef HAVE_UTMPX_H
+#include <utmpx.h>
+#else
 #include <utmp.h>
+#endif
 
 #define	YEAR	(365L*DAY)
 
@@ -248,7 +252,13 @@
  */
 
 void
-failtmp(const struct utmp *failent)
+failtmp(
+#ifdef HAVE_UTMPX_H
+	const struct utmpx *failent
+#else
+	const struct utmp *failent
+#endif
+)
 {
 	char *ftmp;
 	int fd;
--- shadow-4.0.3.orig/libmisc/failure.h
+++ shadow-4.0.3/libmisc/failure.h
@@ -4,7 +4,11 @@
 
 #include "defines.h"
 #include "faillog.h"
+#ifdef HAVE_UTMPX_H
+#include <utmpx.h>
+#else
 #include <utmp.h>
+#endif
 
 /*
  * failure - make failure entry
@@ -38,7 +42,11 @@
  *	failtmp updates the (struct utmp) formatted failure log which
  *	maintains a record of all login failures.
  */
+#ifdef HAVE_UTMPX_H
+extern void failtmp(const struct utmpx *);
+#else
 extern void failtmp(const struct utmp *);
+#endif
 
 #endif
 
--- shadow-4.0.3.orig/configure.in
+++ shadow-4.0.3/configure.in
@@ -138,7 +138,7 @@
 fi
 
 AC_MSG_CHECKING(location of shared mail directory)
-for maildir in /var/spool/mail /var/mail /usr/spool/mail /usr/mail NONE; do
+for maildir in /var/mail /var/spool/mail /usr/spool/mail /usr/mail NONE; do
 	if test "$maildir" = "NONE"; then
 		AC_MSG_RESULT(None)
 	elif test -d $maildir; then
@@ -211,6 +211,7 @@
 AC_ARG_WITH(libpam,   [  --with-libpam           use libpam for PAM support])
 AC_ARG_WITH(libskey,  [  --with-libskey          use libskey for S/Key support])
 AC_ARG_WITH(libtcfs,  [  --with-libtcfs          use libtcfs for TCFS support])
+AC_ARG_WITH(selinux,  [  --with-selinux          use SE Linux support])
 
 dnl Check for some functions in libc first, only if not found check for
 dnl other libraries.  This should prevent linking libnsl if not really
@@ -260,14 +261,20 @@
 	AC_CHECK_LIB(tcfs, tcfs_encrypt_key, AC_DEFINE(HAVE_TCFS) AC_DEFINE(TCFS_GDBM_SUPPORT) LIBTCFS="-ltcfs -lgdbm", , -lgdbm)
 fi
 
+AC_SUBST(SEC_LDADD)
+if test "$with_libpam" = "yes"; then
+	SEC_LDADD=-lselinux
+	CFLAGS="$CFLAGS -DCONFIG_FLASK -I/usr/include/selinux"
+fi
 AC_SUBST(LIBPAM)
 if test "$with_libpam" = "yes"; then
 	AC_CHECK_LIB(pam, pam_start,
 		[AC_DEFINE(USE_PAM)
 		LIBPAM="-lpam"
-		AC_CHECK_LIB(pam_misc, main,
+		AC_CHECK_LIB(pam_misc, misc_conv,
 			[LIBPAM="$LIBPAM -lpam_misc"],
-			AC_MSG_ERROR(libpam_misc is missing)
+			AC_MSG_ERROR(libpam_misc is missing),
+			-lpam
 		)]
 		[AC_MSG_CHECKING(use login access checking if PAM not used)
 		AC_DEFINE(LOGIN_ACCESS)
@@ -305,7 +312,6 @@
 	lib/Makefile
 	src/Makefile
 	contrib/Makefile
-	debian/Makefile
 	etc/Makefile
 	etc/pam.d/Makefile
 	shadow.spec])
--- shadow-4.0.3.orig/Makefile.am
+++ shadow-4.0.3/Makefile.am
@@ -5,4 +5,4 @@
 AUTOMAKE_OPTIONS = 1.5 dist-bzip2 foreign
 
 SUBDIRS = intl po man libmisc lib src \
-	contrib debian doc etc
+	contrib doc etc
